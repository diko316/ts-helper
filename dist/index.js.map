{"version":3,"file":"index.js","sources":["../lib/misc/class.constant.ts","../lib/validation/typeof.constant.ts","../lib/validation/is.constant.ts","../lib/validation/is.function.ts","../lib/validation/is-numeric.constant.ts","../lib/validation/is-numeric.function.ts","../lib/misc/get-global.function.ts","../lib/object/walk-prototype.function.ts","../lib/decorator/get-decorator-call-info.function.ts","../lib/decorator/create-decorator.constant.ts","../lib/decorator/create-decorator.function.ts","../lib/decorator/create-decorator-factory.function.ts","../lib/meta-data/store.constant.ts","../lib/meta-data/is-metadata-key.function.ts","../lib/meta-data/is-metadata-target.function.ts","../lib/meta-data/define-metadata.function.ts","../lib/meta-data/get-own-metadata.function.ts","../lib/meta-data/has-own-metadata.function.ts","../lib/meta-data/get-metadata.function.ts","../lib/meta-data/metadata.decorator.ts","../lib/meta-data/has-metadata.function.ts","../lib/meta-data/polyfill-metadata.function.ts","../lib/meta-data/index.ts","../lib/symbol/object-to-string-tag.decorator.ts","../lib/weak-iterable/weak-iterable.constant.ts","../lib/weak-iterable/weak-iterable.class.ts","../lib/dictionary/dictionary-iterator.constant.ts","../lib/dictionary/dictionary-iterator.class.ts","../lib/dictionary/dictionary.class.ts","../lib/dictionary/create-dictionary.function.ts","../lib/validation/is-numeric-integer.function.ts","../lib/transform/numberify.function.ts"],"sourcesContent":["export const OBJECT_PROTOTYPE = Object.prototype;\n\nexport const FUNCTION_PROTOTYPE = Function.prototype;\n","import {\n  TypeofBigint,\n  TypeofBoolean,\n  TypeofFunction,\n  TypeofNumber,\n  TypeofObject,\n  TypeofString,\n  TypeofSymbol,\n  TypeofUndefined,\n} from './typeof.type';\n\nexport const TYPEOF_UNDEFINED: TypeofUndefined = 'undefined';\nexport const TYPEOF_BOOLEAN: TypeofBoolean = 'boolean';\n\nexport const TYPEOF_STRING: TypeofString = 'string';\nexport const TYPEOF_SYMBOL: TypeofSymbol = 'symbol';\n\nexport const TYPEOF_NUMBER: TypeofNumber = 'number';\nexport const TYPEOF_BIGINT: TypeofBigint = 'bigint';\n\nexport const TYPEOF_OBJECT: TypeofObject = 'object';\nexport const TYPEOF_FUNCTION: TypeofFunction = 'function';\n","import { IsConstructors } from './is.type';\nimport {\n  TYPEOF_BIGINT,\n  TYPEOF_BOOLEAN,\n  TYPEOF_FUNCTION,\n  TYPEOF_NUMBER,\n  TYPEOF_OBJECT,\n  TYPEOF_STRING,\n  TYPEOF_SYMBOL,\n} from './typeof.constant';\n\nexport const PRIMITIVE_TYPE_MAP: Record<string, IsConstructors> = {\n  [TYPEOF_STRING]: String,\n  [TYPEOF_SYMBOL]: Symbol,\n  [TYPEOF_NUMBER]: Number,\n  [TYPEOF_BIGINT]: BigInt,\n  [TYPEOF_BOOLEAN]: Boolean,\n  [TYPEOF_FUNCTION]: Function,\n  [TYPEOF_OBJECT]: Object,\n};","import { AnyClass, AnyType } from '../misc';\nimport { PRIMITIVE_TYPE_MAP } from './is.constant';\nimport { IsConstructors, IsType } from './is.type';\n\nexport function is<\n  Type extends AnyType,\n  Constructor extends IsConstructors = AnyClass\n>(type: Constructor, subject: AnyType): subject is IsType<Constructor, Type> {\n  if (typeof type !== 'function') {\n    return false;\n  }\n\n  switch (type as IsConstructors) {\n    case Boolean:\n    case String:\n    case Number:\n    case BigInt:\n    case Symbol:\n    case Function:\n    case Object:\n      if (PRIMITIVE_TYPE_MAP[typeof subject] !== type) {\n        return false;\n      }\n\n      switch (type as IsConstructors) {\n        case Number:\n          return isFinite(subject);\n        case Object:\n          return subject !== null;\n        default:\n          return true;\n      }\n\n    default:\n      return subject instanceof type;\n  }\n}\n","export const IS_NUMERIC_STRING_PATTERN =\n  /^[+-]?[0-9]+(\\.[0-9]+)?(e[+-]?[0-9])?$/;\n\nexport const IS_NUMERIC_INTEGER_STRING_PATTERN = /^[+-]?[0-9]+$/;\n","import { AnyType } from '../misc';\n\nimport { Numeric } from './is-numeric.type';\n\nimport { IS_NUMERIC_STRING_PATTERN } from './is-numeric.constant';\nimport { TYPEOF_NUMBER, TYPEOF_STRING } from './typeof.constant';\n\nexport function isNumeric<Type>(\n  subject: Type | AnyType\n): subject is Numeric extends Type ? Type : never {\n  switch (typeof subject) {\n    case TYPEOF_STRING:\n      return IS_NUMERIC_STRING_PATTERN.test(subject);\n\n    case TYPEOF_NUMBER:\n      return isFinite(subject);\n\n    default:\n      return false;\n  }\n}\n\nconst c = 'buang';\n\nif (isNumeric<{ name: 1 }>(c)) {\n  console.log('numeric ', c);\n}\n\nif (isNumeric(c)) {\n  console.log('numeric ', c);\n}\n","import { TYPEOF_OBJECT } from '../validation';\n\nexport function getGlobal(): typeof globalThis {\n  if (typeof globalThis === TYPEOF_OBJECT) {\n    return globalThis;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (typeof self === TYPEOF_OBJECT) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return self;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (typeof window === TYPEOF_OBJECT) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return window;\n  }\n\n  if (typeof global === TYPEOF_OBJECT) {\n    return global;\n  }\n\n  return new Function('return this')();\n}\n","import { is } from '../validation';\nimport { AnyClass, AnyObject } from '../misc';\nimport { WalkPrototypeCallback } from './walk-prototype.type';\n\nexport function walkPrototype<Target extends AnyClass | AnyObject>(\n  target: Target,\n  callback: WalkPrototypeCallback\n): Target | null {\n  if (!is(Function, target) && !is(Object, target)) {\n    return null;\n  }\n\n  if (!is(Function, callback)) {\n    return null;\n  }\n\n  let currentTarget: Target | null = target;\n\n  for (; currentTarget; currentTarget = Object.getPrototypeOf(currentTarget)) {\n    const result = callback(currentTarget);\n\n    switch (result) {\n      case true: return currentTarget;\n      case false: return null;\n    }\n  }\n\n  return null;\n}\n","import { AnyClass, ClassInstance } from '../misc';\nimport { is } from '../validation';\n\nimport {\n  DECORATOR_TYPE_ACCESSOR,\n  DECORATOR_TYPE_CLASS,\n  DECORATOR_TYPE_METHOD,\n  DECORATOR_TYPE_PARAMETER,\n  DECORATOR_TYPE_PROPERTY,\n  DECORATOR_TYPE_STATIC_ACCESSOR,\n  DECORATOR_TYPE_STATIC_METHOD,\n  DECORATOR_TYPE_STATIC_PARAMETER,\n  DECORATOR_TYPE_STATIC_PROPERTY,\n} from './create-decorator.constant';\n\nimport {\n  AccessorDecoratorInfo,\n  ClassDecoratorInfo,\n  DecoratorCallParameters,\n  MethodDecoratorInfo,\n  ParameterDecoratorInfo,\n  PropertyDecoratorInfo,\n  StaticAccessorDecoratorInfo,\n  StaticMethodDecoratorInfo,\n  StaticParameterDecoratorInfo,\n  StaticPropertyDecoratorInfo,\n} from './get-decorator-call-info.type';\n\nexport function getDecoratorCallInfo<Class extends AnyClass>([\n  target,\n  property,\n  descriptorOrIndex,\n]: DecoratorCallParameters<Class>):\n  | null\n  | ClassDecoratorInfo<Class>\n  | PropertyDecoratorInfo<Class>\n  | StaticPropertyDecoratorInfo<Class>\n  | MethodDecoratorInfo<Class>\n  | StaticMethodDecoratorInfo<Class>\n  | AccessorDecoratorInfo<Class>\n  | StaticAccessorDecoratorInfo<Class>\n  | ParameterDecoratorInfo<Class>\n  | StaticParameterDecoratorInfo<Class> {\n  //////// For Class Target\n  if (is<Class>(Function, target)) {\n    // indeed a class target if no property\n    if (!property || !is(String, property)) {\n      return {\n        type: DECORATOR_TYPE_CLASS,\n        target,\n      };\n    }\n\n    // if has 3rd parameter is index, then it's a static\n    if (is(Number, descriptorOrIndex)) {\n      return {\n        type: DECORATOR_TYPE_STATIC_PARAMETER,\n        target,\n        property,\n        index: descriptorOrIndex,\n      };\n    }\n\n    // if 3rd parameter is poperty descriptor\n    if (is<PropertyDescriptor>(Object, descriptorOrIndex)) {\n      // if descriptor value is function, then it's a method decorator call\n      if (is(Function, descriptorOrIndex.value)) {\n        return {\n          type: DECORATOR_TYPE_STATIC_METHOD,\n          target,\n          property,\n          descriptor: descriptorOrIndex,\n        };\n      }\n\n      // if not, this is an accessor decorator call\n      return {\n        type: DECORATOR_TYPE_STATIC_ACCESSOR,\n        target,\n        property,\n        descriptor: descriptorOrIndex,\n      };\n    }\n\n    // or if only property exists, then this is a property decorator call\n    return {\n      type: DECORATOR_TYPE_STATIC_PROPERTY,\n      target,\n      property,\n    };\n  }\n\n  // if target is not an object or property is empty, then this is invalid\n  if (!is<ClassInstance<Class>>(Object, target) || !property) {\n    return null;\n  }\n\n  //////// For Prototype Target\n\n  // if has 3rd parameter is index, then it's a static\n  if (is(Number, descriptorOrIndex)) {\n    return {\n      type: DECORATOR_TYPE_PARAMETER,\n      target,\n      property,\n      index: descriptorOrIndex,\n    };\n  }\n\n  // if 3rd parameter is poperty descriptor\n  if (is<PropertyDescriptor>(Object, descriptorOrIndex)) {\n    // if descriptor value is function, then it's a method decorator call\n    if (is(Function, descriptorOrIndex.value)) {\n      return {\n        type: DECORATOR_TYPE_METHOD,\n        target,\n        property,\n        descriptor: descriptorOrIndex,\n      };\n    }\n\n    // if not, this is an accessor decorator call\n    return {\n      type: DECORATOR_TYPE_ACCESSOR,\n      target,\n      property,\n      descriptor: descriptorOrIndex,\n    };\n  }\n\n  // or if only property exists, then this is a property decorator call\n  return {\n    type: DECORATOR_TYPE_PROPERTY,\n    target,\n    property,\n  };\n}\n","import {\n  DecoratorTypeAccessorDecorator,\n  DecoratorTypeClassDecorator,\n  DecoratorTypeMethodDecorator,\n  DecoratorTypeParameterDecorator,\n  DecoratorTypePropertyDecorator,\n  DecoratorTypeStaticAccessorDecorator,\n  DecoratorTypeStaticMethodDecorator,\n  DecoratorTypeStaticParameterDecorator,\n  DecoratorTypeStaticPropertyDecorator,\n} from './get-decorator-call-info.type';\n\nexport const DECORATOR_TYPE_CLASS: DecoratorTypeClassDecorator = 1;\n\nexport const DECORATOR_TYPE_PROPERTY: DecoratorTypePropertyDecorator = 2;\nexport const DECORATOR_TYPE_STATIC_PROPERTY: DecoratorTypeStaticPropertyDecorator = 3;\n\nexport const DECORATOR_TYPE_METHOD: DecoratorTypeMethodDecorator = 4;\nexport const DECORATOR_TYPE_STATIC_METHOD: DecoratorTypeStaticMethodDecorator = 5;\n\nexport const DECORATOR_TYPE_ACCESSOR: DecoratorTypeAccessorDecorator = 6;\nexport const DECORATOR_TYPE_STATIC_ACCESSOR: DecoratorTypeStaticAccessorDecorator = 7;\n\nexport const DECORATOR_TYPE_PARAMETER: DecoratorTypeParameterDecorator = 8;\nexport const DECORATOR_TYPE_STATIC_PARAMETER: DecoratorTypeStaticParameterDecorator = 9;\n","import { AnyClass, AnyType } from '../misc';\n\nimport {\n  DECORATOR_TYPE_ACCESSOR,\n  DECORATOR_TYPE_CLASS,\n  DECORATOR_TYPE_METHOD,\n  DECORATOR_TYPE_PARAMETER,\n  DECORATOR_TYPE_PROPERTY,\n  DECORATOR_TYPE_STATIC_ACCESSOR,\n  DECORATOR_TYPE_STATIC_METHOD,\n  DECORATOR_TYPE_STATIC_PARAMETER,\n  DECORATOR_TYPE_STATIC_PROPERTY,\n} from './create-decorator.constant';\n\nimport {\n  CreateDecoratorOptions,\n  UnifiedDecorator,\n} from './create-decorator.type';\nimport { getDecoratorCallInfo } from './get-decorator-call-info.function';\nimport { DecoratorCallParameters } from './get-decorator-call-info.type';\n\nexport function createDecorator<Settings>({\n  settings,\n  classDecorator,\n  propertyDecorator,\n  methodDecorator,\n  accessorDecorator,\n  parameterDecorator,\n  staticPropertyDecorator,\n  staticMethodDecorator,\n  staticAccessorDecorator,\n  staticParameterDecorator,\n}: Partial<CreateDecoratorOptions<Settings>>): UnifiedDecorator {\n  function decorator<Class extends AnyClass>(\n    ...callParams: DecoratorCallParameters<Class>\n  ): AnyType {\n    const info = getDecoratorCallInfo(callParams);\n\n    switch (info?.type) {\n      case DECORATOR_TYPE_CLASS:\n        if (classDecorator) {\n          return classDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_PROPERTY:\n        if (propertyDecorator) {\n          return propertyDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_STATIC_PROPERTY:\n        if (staticPropertyDecorator) {\n          return staticPropertyDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_METHOD:\n        if (methodDecorator) {\n          return methodDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_STATIC_METHOD:\n        if (staticMethodDecorator) {\n          return staticMethodDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_ACCESSOR:\n        if (accessorDecorator) {\n          return accessorDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_STATIC_ACCESSOR:\n        if (staticAccessorDecorator) {\n          return staticAccessorDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_PARAMETER:\n        if (parameterDecorator) {\n          return parameterDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      case DECORATOR_TYPE_STATIC_PARAMETER:\n        if (staticParameterDecorator) {\n          return staticParameterDecorator({\n            ...info,\n            settings: settings as Settings,\n          });\n        }\n        return;\n\n      default:\n        return;\n    }\n  }\n\n  return decorator;\n}\n","import { AnyArray } from '../misc';\nimport {\n  CreateDecoratorFactoryOptions,\n  UnifiedDecoratorFactory,\n} from './create-decorator-factory.type';\nimport { createDecorator } from './create-decorator.function';\nimport { UnifiedDecorator } from './create-decorator.type';\n\nexport function createDecoratorFactory<Settings, Params extends AnyArray>({\n  initialize,\n  ...options\n}: CreateDecoratorFactoryOptions<\n  Settings,\n  Params\n>): UnifiedDecoratorFactory<Params> {\n  function factory(...args: Params): UnifiedDecorator {\n    return createDecorator({\n      ...options,\n      settings: initialize(...args),\n    });\n  }\n\n  return factory;\n}\n","import { MetadataStore } from './store.type';\n\nexport const METADATA_STORE: MetadataStore = new WeakMap();\n\nexport const DEFAULT_METADATA_PROPERTY_KEY = Symbol('metadata:property');\n","import { is } from '../validation';\nimport { AnyType } from '../misc';\nimport { MetadataKey } from './meta-data.type';\n\nexport function isMetadataKey<MetaKey extends MetadataKey>(\n  key: AnyType\n): key is MetaKey {\n  return (is(String, key) && key.length > 0) || is(Symbol, key);\n}\n","import { is } from '../validation';\nimport { AnyType } from '../misc';\nimport { MetadataTarget } from './meta-data.type';\n\nexport function isMetadataTarget<\n  ClassOrInstance extends MetadataTarget = MetadataTarget\n>(target: AnyType): target is ClassOrInstance {\n  return is(Object, target) || is(Function, target);\n}\n","import { TYPEOF_UNDEFINED } from '../validation';\nimport {\n  DEFAULT_METADATA_PROPERTY_KEY,\n  METADATA_STORE,\n} from './store.constant';\nimport {\n  MetadataKey,\n  MetadataPropertyKey,\n  MetadataTarget,\n  MetadataValue,\n} from './meta-data.type';\nimport { isMetadataKey } from './is-metadata-key.function';\nimport { isMetadataTarget } from './is-metadata-target.function';\nimport { isMetadataPropertyKey } from './is-metadata-property-key.function';\n\nexport function defineMetadata<ClassOrInstance extends MetadataTarget>(\n  key: MetadataKey,\n  value: MetadataValue,\n  target: ClassOrInstance,\n  propertyKey?: MetadataPropertyKey\n): void {\n  if (!isMetadataKey(key) || !isMetadataTarget(target)) {\n    return;\n  }\n\n  // don't store undefined!\n  if (typeof value === TYPEOF_UNDEFINED) {\n    return;\n  }\n\n  let definition = METADATA_STORE.get(target);\n\n  if (!definition) {\n    METADATA_STORE.set(target, (definition = new Map()));\n  }\n\n  const access = isMetadataPropertyKey(propertyKey)\n    ? propertyKey\n    : DEFAULT_METADATA_PROPERTY_KEY;\n\n  let property = definition.get(access);\n  if (!property) {\n    property = new Map();\n    definition.set(access, property);\n  }\n\n  property.set(key, value);\n\n  return;\n}\n","import {\n  DEFAULT_METADATA_PROPERTY_KEY,\n  METADATA_STORE,\n} from './store.constant';\nimport {\n  MetadataKey,\n  MetadataPropertyKey,\n  MetadataTarget,\n  MetadataValue,\n} from './meta-data.type';\nimport { isMetadataKey } from './is-metadata-key.function';\nimport { isMetadataTarget } from './is-metadata-target.function';\nimport { isMetadataPropertyKey } from './is-metadata-property-key.function';\n\nexport function getOwnMetadata<ClassOrInstance extends MetadataTarget>(\n  key: MetadataKey,\n  target: ClassOrInstance,\n  propertyKey?: MetadataPropertyKey\n): MetadataValue {\n  if (!isMetadataKey(key) || !isMetadataTarget(target)) {\n    return;\n  }\n\n  // store\n  return (\n    METADATA_STORE.get(target)\n      // property\n      ?.get(\n        isMetadataPropertyKey(propertyKey)\n          ? propertyKey\n          : DEFAULT_METADATA_PROPERTY_KEY\n      )\n      // definition\n      ?.get(key)\n  );\n}\n","import { isMetadataKey } from './is-metadata-key.function';\nimport { isMetadataPropertyKey } from './is-metadata-property-key.function';\nimport { isMetadataTarget } from './is-metadata-target.function';\nimport {\n  MetadataKey,\n  MetadataPropertyKey,\n  MetadataTarget,\n} from './meta-data.type';\nimport {\n  DEFAULT_METADATA_PROPERTY_KEY,\n  METADATA_STORE,\n} from './store.constant';\n\nexport function hasOwnMetadata<ClassOrInstance extends MetadataTarget>(\n  key: MetadataKey,\n  target: ClassOrInstance,\n  propertyKey?: MetadataPropertyKey\n): boolean {\n  if (!isMetadataKey(key) || !isMetadataTarget(target)) {\n    return false;\n  }\n\n  const definition = METADATA_STORE.get(target);\n\n  if (!definition) {\n    return false;\n  }\n\n  const property = definition.get(\n    isMetadataPropertyKey(propertyKey)\n      ? propertyKey\n      : DEFAULT_METADATA_PROPERTY_KEY\n  );\n  if (!property) {\n    return false;\n  }\n\n  return property.has(key);\n}\n","import { walkPrototype } from '../object/walk-prototype.function';\nimport { getOwnMetadata } from './get-own-metadata.function';\nimport { hasOwnMetadata } from './has-own-metadata.function';\nimport { isMetadataKey } from './is-metadata-key.function';\nimport { isMetadataPropertyKey } from './is-metadata-property-key.function';\nimport { isMetadataTarget } from './is-metadata-target.function';\nimport {\n  MetadataKey,\n  MetadataPropertyKey,\n  MetadataTarget,\n  MetadataValue,\n} from './meta-data.type';\nimport { DEFAULT_METADATA_PROPERTY_KEY } from './store.constant';\n\nexport function getMetadata<ClassOrInstance extends MetadataTarget>(\n  key: MetadataKey,\n  target: ClassOrInstance,\n  propertyKey?: MetadataPropertyKey\n): MetadataValue {\n  if (!isMetadataTarget(target) || !isMetadataKey(key)) {\n    return false;\n  }\n  const access = isMetadataPropertyKey(propertyKey)\n    ? propertyKey\n    : DEFAULT_METADATA_PROPERTY_KEY;\n\n  function foundMetadata(currentTarget: MetadataTarget): boolean {\n    return hasOwnMetadata(key, currentTarget, access);\n  }\n\n  const result = walkPrototype(target, foundMetadata);\n\n  if (!result) {\n    return;\n  }\n\n  return getOwnMetadata(key, result, access);\n}\n","import { defineMetadata } from './define-metadata.function';\nimport {\n  MetadataKey,\n  MetadataPropertyKey,\n  MetadataTarget,\n  MetadataValue,\n} from './meta-data.type';\n\nexport function metadata(\n  key: MetadataKey,\n  value: MetadataValue\n): (target: MetadataTarget, propertyKey?: MetadataPropertyKey) => void {\n  function metaDecorator(\n    target: MetadataTarget,\n    propertyKey?: MetadataPropertyKey\n  ): void {\n    defineMetadata(key, value, target, propertyKey);\n  }\n\n  return metaDecorator;\n}\n","import { walkPrototype } from '../object/walk-prototype.function';\nimport { hasOwnMetadata } from './has-own-metadata.function';\nimport { isMetadataKey } from './is-metadata-key.function';\nimport { isMetadataPropertyKey } from './is-metadata-property-key.function';\nimport { isMetadataTarget } from './is-metadata-target.function';\nimport {\n  MetadataKey,\n  MetadataPropertyKey,\n  MetadataTarget,\n} from './meta-data.type';\nimport { DEFAULT_METADATA_PROPERTY_KEY } from './store.constant';\n\nexport function hasMetadata<ClassOrInstance extends MetadataTarget>(\n  key: MetadataKey,\n  target: ClassOrInstance,\n  propertyKey?: MetadataPropertyKey\n): boolean {\n  if (!isMetadataTarget(target) || !isMetadataKey(key)) {\n    return false;\n  }\n  const access = isMetadataPropertyKey(propertyKey)\n    ? propertyKey\n    : DEFAULT_METADATA_PROPERTY_KEY;\n\n  function foundMetadata(currentTarget: MetadataTarget): boolean {\n    return hasOwnMetadata(key, currentTarget, access);\n  }\n\n  return walkPrototype(target, foundMetadata) !== null;\n}\n","import { TYPEOF_FUNCTION, TYPEOF_OBJECT } from '../validation';\nimport { AnyObject, getGlobal } from '../misc';\nimport { defineMetadata } from './define-metadata.function';\nimport { getMetadata } from './get-metadata.function';\nimport { metadata } from './metadata.decorator';\nimport { getOwnMetadata } from './get-own-metadata.function';\nimport { hasMetadata } from './has-metadata.function';\nimport { hasOwnMetadata } from './has-own-metadata.function';\n\ninterface PolyfilledMetadata {\n  metadata: typeof metadata;\n  defineMetadata: typeof defineMetadata;\n  getMetadata: typeof getMetadata;\n  hasMetadata: typeof hasMetadata;\n\n  getOwnMetadata: typeof getOwnMetadata;\n  hasOwnMetadata: typeof hasOwnMetadata;\n}\n\nlet APPLIED: PolyfilledMetadata | false = false;\n\nfunction getOrSetReflectObject(scope: AnyObject): PolyfilledMetadata {\n  if (typeof scope.Reflect === TYPEOF_OBJECT) {\n    return scope.Reflect;\n  }\n\n  const filler = {} as PolyfilledMetadata;\n  scope.Reflect = filler;\n\n  return filler;\n}\n\nfunction applyReflectMethodIf<Name extends keyof PolyfilledMetadata>(\n  methodName: Name,\n  polyfill: PolyfilledMetadata[Name],\n  reflect: PolyfilledMetadata,\n  target: PolyfilledMetadata\n): void {\n  if (typeof reflect[methodName] === TYPEOF_FUNCTION) {\n    target[methodName] = reflect[methodName];\n    return;\n  }\n\n  target[methodName] = reflect[methodName] = polyfill;\n}\n\nexport function polyfillMetadata(): PolyfilledMetadata {\n  if (APPLIED) {\n    return APPLIED;\n  }\n\n  const reflect = getOrSetReflectObject(getGlobal());\n\n  APPLIED = {} as PolyfilledMetadata;\n\n  applyReflectMethodIf('metadata', metadata, reflect, APPLIED);\n  applyReflectMethodIf('defineMetadata', defineMetadata, reflect, APPLIED);\n  applyReflectMethodIf('getMetadata', getMetadata, reflect, APPLIED);\n  applyReflectMethodIf('hasMetadata', hasMetadata, reflect, APPLIED);\n\n  applyReflectMethodIf('getOwnMetadata', getOwnMetadata, reflect, APPLIED);\n  applyReflectMethodIf('hasOwnMetadata', hasOwnMetadata, reflect, APPLIED);\n\n  return APPLIED;\n}\n","import { polyfillMetadata } from './polyfill-metadata.function';\n\nconst {\n  metadata,\n  defineMetadata,\n  getMetadata,\n  hasMetadata,\n\n  getOwnMetadata,\n  hasOwnMetadata,\n} = polyfillMetadata();\n\nexport {\n  metadata,\n  defineMetadata,\n  getMetadata,\n  hasMetadata,\n  getOwnMetadata,\n  hasOwnMetadata,\n};\n","import { createDecoratorFactory } from '../decorator';\nimport { is } from '../validation';\n\nexport const ObjectToStringTag = createDecoratorFactory({\n  initialize(name: string): string {\n    if (!name || !is(String, name)) {\n      throw new TypeError();\n    }\n\n    return name;\n  },\n\n  classDecorator({ settings: name, target }) {\n    Object.defineProperty(target.prototype, Symbol.toStringTag, {\n      value: name,\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n  },\n});\n","import { AnyType } from \"../misc\";\n\nexport const WEAK_ITERABLE_LOOKUP = new WeakMap<Iterator<AnyType>, AnyType>();\n","import { AnyObject, AnyType } from '../misc';\nimport { WEAK_ITERABLE_LOOKUP } from './weak-iterable.constant';\n\nimport { ObjectToStringTag } from '../symbol';\n\n@ObjectToStringTag('WeakIterable')\nexport abstract class WeakIterable<\n  IterableInstance extends AnyObject,\n  Item = AnyType\n> implements Iterator<Item, Item>\n{\n  protected get instance(): IterableInstance {\n    return WEAK_ITERABLE_LOOKUP.get(this);\n  }\n\n  constructor(instance: IterableInstance) {\n    WEAK_ITERABLE_LOOKUP.set(this, instance);\n  }\n\n  next(): IteratorResult<Item> {\n    return {\n      done: true,\n      value: undefined,\n    };\n  }\n}\n","export const DICTIONARY_ITERATOR_STATE_KEY = Symbol(\n  'dictionary:iterator_state'\n);\n","import { AnyType } from '../misc';\nimport { ObjectToStringTag } from '../symbol';\nimport { WeakIterable } from '../weak-iterable/weak-iterable.class';\nimport { DICTIONARY_ITERATOR_STATE_KEY } from './dictionary-iterator.constant';\nimport { Dictionary, DictionaryInput } from './dictionary.type';\n\n@ObjectToStringTag('DictionaryIterator')\nexport class DictionaryIterator<\n  Item extends DictionaryInput<AnyType>\n> extends WeakIterable<Dictionary<Item>, Item> {\n\n  [DICTIONARY_ITERATOR_STATE_KEY] = 0;\n\n  next(): IteratorResult<Item> {\n    const instance = this.instance;\n    const size = instance.size;\n    const index = this[DICTIONARY_ITERATOR_STATE_KEY];\n\n    this[DICTIONARY_ITERATOR_STATE_KEY] = Math.min(index + 1, size);\n\n    if (index < size) {\n      return {\n        done: false,\n        value: instance.itemAt(index) as Item,\n      };\n    }\n\n    return {\n      done: true,\n      value: instance.itemAt(index),\n    };\n  }\n}\n\n\n","import { is } from '../validation';\nimport { AnyType } from '../misc';\nimport { ObjectToStringTag } from '../symbol';\n\nimport {\n  DictionaryElementCursor,\n  DictionaryInput,\n  DictionaryInputElement,\n  DictionaryList,\n  DictionaryState,\n  Dictionary as DictionaryModel,\n  DictionaryInputBuffer,\n} from './dictionary.type';\n\nimport { DictionaryIterator } from './dictionary-iterator.class';\n\n@ObjectToStringTag('Dictionary')\nexport class Dictionary<Item extends DictionaryInput<AnyType>>\n  implements DictionaryModel<Item>\n{\n  protected readonly entryState: DictionaryState<DictionaryInputElement<Item>> =\n    new Map();\n\n  protected readonly endStates: Map<\n    DictionaryState<DictionaryInputElement<Item>>,\n    DictionaryInputBuffer<Item>\n  > = new Map();\n\n  get size(): number {\n    return this.endStates.size;\n  }\n\n  [Symbol.iterator](): Iterator<Item, Item, Item | undefined> {\n    return new DictionaryIterator(this);\n  }\n\n  list(): DictionaryList<Item> {\n    const ends = this.endStates;\n\n    const found: DictionaryList<Item> = [];\n    let count = 0;\n\n    const iterator = ends.keys();\n\n    for (\n      let { done, value } = iterator.next();\n      !done;\n      { done, value } = iterator.next()\n    ) {\n      found[count++] = ends.get(value)?.slice(0) || [];\n    }\n\n    return found;\n  }\n\n  has<Items extends DictionaryInputBuffer<Item>>(set: Items): set is Items {\n    if (!is<Items>(Array, set)) {\n      return false;\n    }\n\n    let length = set.length;\n\n    if (!length) {\n      return false;\n    }\n\n    let state = this.entryState;\n\n    // find until end of list\n    for (let c = 0; length--; c++) {\n      const value = set[c];\n\n      if (!state.has(value)) {\n        return false;\n      }\n\n      state = state.get(value) as DictionaryState<Item>;\n    }\n\n    return this.endStates.has(state);\n  }\n\n  add<Items extends DictionaryInputBuffer<Item>>(set: Items): this {\n    if (!is(Array, set)) {\n      throw new TypeError();\n    }\n\n    let length = set.length;\n\n    if (!length) {\n      return this;\n    }\n\n    let state = this.entryState;\n\n    for (let c = 0; length--; c++) {\n      const value = set[c];\n\n      if (state.has(value)) {\n        state = state.get(value) as DictionaryState<Item>;\n        continue;\n      }\n\n      state.set(value, (state = new Map()));\n    }\n\n    // register end state\n    const ends = this.endStates;\n    if (!ends.has(state)) {\n      ends.set(state, [...set]);\n    }\n\n    return this;\n  }\n\n  remove<Items extends DictionaryInputBuffer<Item>>(set: Items): this {\n    if (!is(Array, set)) {\n      return this;\n    }\n\n    let length = set.length;\n\n    if (!length) {\n      return this;\n    }\n\n    const buffer: DictionaryElementCursor<Item> = [];\n    let value: DictionaryInputElement<Item>;\n    let bufferCount = 0;\n    let failed = false;\n    let state = this.entryState;\n\n    // find until end of list\n    for (let c = 0; length--; c++) {\n      value = set[c];\n\n      // not found\n      if (!state.has(value)) {\n        failed = true;\n        break;\n      }\n\n      buffer[bufferCount++] = [state, value];\n      state = state.get(value) as DictionaryState<Item>;\n    }\n\n    const ends = this.endStates;\n\n    // end state not found!\n    if (!ends.has(state) || failed) {\n      buffer.splice(0, bufferCount);\n      return this;\n    }\n\n    // unset buffer\n    const endStateBuffer = ends.get(state);\n\n    endStateBuffer?.splice(0, endStateBuffer.length);\n    ends.delete(state);\n\n    for (; bufferCount--; ) {\n      [state, value] = buffer[bufferCount];\n      const target = state.get(value) as DictionaryState<Item>;\n\n      if (target.size || ends.has(target)) {\n        break;\n      }\n\n      // delete!\n      state.delete(value);\n    }\n\n    buffer.splice(0, bufferCount);\n\n    return this;\n  }\n\n  clear(): this {\n    const buffer: Array<DictionaryState<Item>> = [this.entryState];\n    let bufferCount = 1;\n\n    for (; bufferCount; ) {\n      const node = buffer[bufferCount - 1];\n\n      if (!node.size) {\n        buffer.length = --bufferCount;\n        continue;\n      }\n\n      const nodeIterator = node.keys();\n\n      for (\n        let { done, value: key } = nodeIterator.next();\n        !done;\n        { done, value: key } = nodeIterator.next()\n      ) {\n        const value = node.get(key);\n\n        if (value?.size) {\n          buffer[bufferCount++] = value;\n          continue;\n        }\n        node.delete(key);\n      }\n    }\n\n    const ends = this.endStates;\n    const endsIterator = ends.keys();\n\n    for (\n      let { done, value: state } = endsIterator.next();\n      !done;\n      { done, value: state } = endsIterator.next()\n    ) {\n      const item = ends.get(state);\n\n      if (item) {\n        item.splice(0, item.length);\n      }\n\n      ends.delete(state);\n    }\n\n    return this;\n  }\n\n  itemAt(index: number): DictionaryInputBuffer<Item> | undefined {\n    if (index < 0) {\n      return;\n    }\n\n    const ends = this.endStates;\n\n    if (index >= ends.size) {\n      return;\n    }\n\n    const iterator = ends.keys();\n\n    for (\n      let c = 0, result = iterator.next();\n      !result.done;\n      result = iterator.next()\n    ) {\n      // found!\n      if (c++ === index) {\n        return ends.get(result.value)?.slice(0) || [];\n      }\n    }\n\n    return;\n  }\n\n  indexOf<Items extends DictionaryInputBuffer<Item>>(set: Items): number {\n    if (!is<Items>(Array, set)) {\n      return -1;\n    }\n\n    let length = set.length;\n\n    if (!length) {\n      return -1;\n    }\n\n    let state = this.entryState;\n\n    // find until end of list\n    for (let c = 0; length--; c++) {\n      const value = set[c];\n\n      if (!state.has(value)) {\n        return -1;\n      }\n\n      state = state.get(value) as DictionaryState<Item>;\n    }\n\n    // find index via ends Order\n    const ends = this.endStates;\n    const iterator = ends.keys();\n\n    for (\n      let index = 0, result = iterator.next();\n      !result.done;\n      result = iterator.next()\n    ) {\n      // found!\n      if (result.value === state) {\n        return index;\n      }\n\n      index++;\n    }\n\n    return -1;\n  }\n\n  toString(): string {\n    return `Dictionary ${JSON.stringify(this.list())}`;\n  }\n\n  toJSON(): string {\n    return `Dictionary ${JSON.stringify(this.list())}`;\n  }\n}\n","import { is } from '../validation';\nimport { AnyType } from '../misc';\nimport { Dictionary as DictionaryConstructor } from './dictionary.class';\nimport { DictionaryInput } from './dictionary.type';\n\nexport function createDictionary<Item extends DictionaryInput<AnyType>>(\n  items?: Array<Item>\n): DictionaryConstructor<Item> {\n  if (items && !is(Array, items)) {\n    throw new TypeError();\n  }\n\n  const instance = new DictionaryConstructor<Item>();\n\n  if (items?.length) {\n    items.forEach(\n      (item) => instance.add(item)\n    );\n  }\n\n  return instance;\n}\n","import { AnyType } from '../misc';\n\nimport { Numeric } from './is-numeric.type';\n\nimport { TYPEOF_NUMBER, TYPEOF_STRING } from './typeof.constant';\nimport { IS_NUMERIC_INTEGER_STRING_PATTERN } from './is-numeric.constant';\n\nexport function isNumericInteger<Type>(\n  subject: Type | AnyType\n): subject is Numeric extends Type ? Type : never {\n  switch (typeof subject) {\n    case TYPEOF_STRING:\n      return IS_NUMERIC_INTEGER_STRING_PATTERN.test(subject);\n\n    case TYPEOF_NUMBER:\n      return isFinite(subject);\n\n    default:\n      return false;\n  }\n}\n","import { AnyType } from '../misc';\n\nimport { TYPEOF_NUMBER, TYPEOF_STRING } from '../validation';\nimport { IS_NUMERIC_STRING_PATTERN } from '../validation/is-numeric.constant';\n\nexport function numberify<Result = undefined>(\n  subject: AnyType,\n  defaultValue?: Result\n): Result | number {\n  switch (typeof subject) {\n    case TYPEOF_STRING:\n      return IS_NUMERIC_STRING_PATTERN.test(subject as string)\n        ? parseFloat(subject as string)\n        : (defaultValue as Result);\n\n    case TYPEOF_NUMBER:\n      return isFinite(subject as number)\n        ? (subject as number)\n        : (defaultValue as Result);\n\n    default:\n      return defaultValue as Result;\n  }\n}\n"],"names":["OBJECT_PROTOTYPE","Object","prototype","FUNCTION_PROTOTYPE","Function","TYPEOF_UNDEFINED","TYPEOF_BOOLEAN","TYPEOF_STRING","TYPEOF_SYMBOL","TYPEOF_NUMBER","TYPEOF_BIGINT","TYPEOF_OBJECT","TYPEOF_FUNCTION","PRIMITIVE_TYPE_MAP","is","type","subject","Boolean","String","Number","BigInt","Symbol","isFinite","const","IS_NUMERIC_STRING_PATTERN","IS_NUMERIC_INTEGER_STRING_PATTERN","isNumeric","test","c","getGlobal","globalThis","self","window","global","walkPrototype","target","callback","let","currentTarget","getPrototypeOf","console","log","getDecoratorCallInfo","ref","property","descriptorOrIndex","index","value","descriptor","createDecorator","settings","classDecorator","propertyDecorator","methodDecorator","accessorDecorator","parameterDecorator","staticPropertyDecorator","staticMethodDecorator","staticAccessorDecorator","info","callParams","assign","staticParameterDecorator","createDecoratorFactory","initialize","objectWithoutProperties","options","apply","args","METADATA_STORE","WeakMap","DEFAULT_METADATA_PROPERTY_KEY","isMetadataKey","key","length","isMetadataTarget","defineMetadata","propertyKey","definition","get","set","Map","access","isMetadataPropertyKey","getOwnMetadata","_b","_a","hasOwnMetadata","has","getMetadata","result","metadata","hasMetadata","APPLIED","applyReflectMethodIf","methodName","polyfill","reflect","scope","Reflect","filler","getOrSetReflectObject","polyfillMetadata","ObjectToStringTag","name","TypeError","defineProperty","toStringTag","configurable","enumerable","writable","WEAK_ITERABLE_LOOKUP","WeakIterable","instance","this","prototypeAccessors","next","done","undefined","__decorate","DICTIONARY_ITERATOR_STATE_KEY","DictionaryIterator","constructor","size","Math","min","itemAt","Dictionary","entryState","endStates","iterator","list","ends","found","count","keys","slice","Array","state","add","concat","remove","buffer","bufferCount","failed","splice","endStateBuffer","delete","clear","node","nodeIterator","endsIterator","done$1","ref$1","assign$1","item","indexOf","toString","JSON","stringify","toJSON","items","DictionaryConstructor","forEach","defaultValue","parseFloat"],"mappings":"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"}